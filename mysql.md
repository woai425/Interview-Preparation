# 面试准备 #
**2018-01-10 write by fxf at hz** 
## DB-MySQL ##
### 1,MySQL的三范式，并举例 ### 

**第一范式(1NF)：**在一张表中，如果每个字段值都是不可再分的最小数据单位，则称表是符合第一范式的关系。

> 比如用户表，主键id，个人介绍两个字段，就不符合。
> 
> 因为个人介绍可以分为姓名、年龄、性别等

**第二范式：**表中的其他字段都完全依赖于某一个字段（候选关键字）

> 如选课关系表SCI(SNO，CNO，GRADE，CREDIT)；
> 
> 其中SNO为学号，CNO为课程号，GRADEGE为成绩，CREDIT为学分。
> 
> 学分依赖课程，成绩依赖学号。不完全依赖，有冗余
> 
> 解决方式：分成两个关系模式表SC1(SNO，CNO，GRADE)，C2(CNO，CREDIT)。

**第三范式：**表中的字段间不存在传递依赖。

> 如S1(SNO，SNAME，DNO，DNAME，LOCATION)各属性分别代表学号，姓名，所在系，系名称，系地址。关系中存在传递依赖。
> 
> 即SNO->DNO，DNO->LOCATION，
> 因此关键字SNO对LOCATION关系是通过传递依赖SNO-> DNO -> LOCATION实现的。也就是说，SNO不直接决定非主属性LOCATION。
> 
> 解决方法：分为两个关系表S(SNO，SNAME，DNO)，D(DNO，DNAME，LOCATION)；
> 注意：关系S中不能没有外关键字DNO。
> 否则两个关系之间失去联系。

### 2,数据库关系完整性 ###

关系完整性：
是为保证数据库中数据的正确性和相容性，对关系模型提出的某种约束条件或规则。完整性通常包括域完整性，实体完整性、参照完整性

- **域完整性约束：**域完整性是保证数据库字段取值的合理性。??包括检查(CHECK)、默认值(DEFAULT)、不为空(NOT?NULL)等
- **实体完整性：**是指关系的主关键字不能重复也不能取“空值\"。如将职工编号作为主关键字，那么，该列不得有空值，否则无法对应某个具体的职工
- **参照完整性：**是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。外键的值只能是他引用的其他表的主键的值。
	
### 3，sql优化：（缓存、索引、优化思路、分表） ###

#### 缓存： ####
	
	redis、不影响原有的业务逻辑
	一级缓存、hibernate或mybatis中的session级别内置缓存，默认开启
	二级缓存、同一个sessionFactory的多个session实例之间的缓存，需手动开启
	
#### 索引：（排好序） ####
	
	可以利用索引快速访问数据库表中的特定信息。
	索引是对数据库表中一个或多个列的值进行排序的结构。
	如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。
	索引提供指针以指向存储在表中指定列的数据值，然后根据指定的排序次序排列这些指针。
	通常情况下，只有当经常查询索引列中的数据时，才需要在表上创建索引。
	索引会占用磁盘空间，并且降低添加、删除和更新行的速度。
	不过在多数情况下，索引所带来的数据检索速度的优势大大超过它的不足之处。
	如果应用程序非常频繁地更新数据，或磁盘空间有限，那么最好限制索引的数量。

#### 优化案例： ####
	
	参考子查询，尽量不用子查询。
	
#### 分库分表： ####
	
	无

### 4，多表连接： ###
	
	inner join:内连接，也叫等值连接，产生同时符合A和B的一组数据。
	left join:左连接,从左表(A)产生一套完整的记录,与匹配的记录(右表(B)) .如果没有匹配,右侧将包含null。
	right join：右连接，同左连接
	union:全连接，去重；左右连接+union可取差集
	union all: 全连接，不去重
	cross join：交叉连接，得到的结果是两个表的乘积，即笛卡尔积

### 5，子查询： ###
	
	关于mysql的查询有两个知识点:

	第一个知识点：mysql在处理所有的查询的时候都强行转换为联接来执行，将每个查询包括多表中关联匹配，关联子查询，union，
	甚至单表的的查询都处理为联接，接着mysql执行联接，把每个联接在处理为一个嵌套循环(oracle-nest-loop);

	第二个知识点：在mysql在处理子查询的时候，会将将子查询改写,通常情况下，我们希望由内到外，先完成子查询的结果，
	然后在用子查询来驱动外查询的表，完成查询，
		
	例如：
		Select * from test where test_id in(select fk_test_id from sub_test where group_id=10)

	通常我们会想到该sql的执行顺序为：	

	sub_test表中根据group_id取得fk_test_id(2,3,4,5,6),然后在到test中，带入test_id=2,3,4,5,6取得查询数据，

	但是实际mysql的处理方式为：	

	Select * from test where exists (select * from sub_test where group_id=10 and sub_test.test_id=test.id)
	
	mysql将会扫描test中的所有数据，每条数据将会传到子查询中与sub_test关联，子查询不能首先被执行，如果test表很大的话，那么性能上将会出现问题；
	
	这时候就需要改写查询了：
	
	select t1.* from test t1,(select fk_test_id from sub_test where group_id=10 ) t2 where t1.test_id=t2.fk_test_id ;

			
### 6，事务： ###
	
	是指作为单个逻辑工作单元执行的一系列操作。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。
	通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。
	一个逻辑工作单元要成为事务，必须满足所谓的ACID(原子性、一致性、隔离性和持久性)属性。
	(1).原子性(atomicity)
		事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。
	(2).一致性(consistency)
		事务在完成时，必须使所有的数据都保持一致状态。在一系列操作中所做的修改对数据的完整性（约束）没有影响。
	(3).隔离性(isolation)
		一个事务所作的修改必须与任何其它事务所作的修改隔离。
		即一个事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，
	  	事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。
	  	在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。防止数据丢失
	(4).持久性(Duration)
		事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。
				
### 7，存储过程的优点 ###
		
	1.存储过程因为SQL语句已经预编绎过了，因此运行的速度比较快。
	2.可保证数据的安全性和完整性。（封装和隐藏了数据逻辑。）
		通过存储过程可以使没有权限的用户在控制之下间接地存取数据库，从而保证数据的安全。
		通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。
	3.可以降低网络的通信量。存储过程主要是在服务器上运行，减少对客户机的压力。
	4.存储过程可以接受参数、输出参数、返回单个或多个结果集。没有返回值，但是函数有返回值。
	5.存储过程可以包含程序流、逻辑以及对数据库的查询。
		
### 8，触发器： ###
		
	触发器对表进行插入、更新、删除的时候会自动执行的特殊存储过程。
	它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作(insert，delete，update)时就会激活它执行。
		
### 9，锁： ###
		